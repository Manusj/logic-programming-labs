% The datastructure used to denote state is [[ML,CL],[MR,CR],boatside] where,
%						 ML is the number of missionaries on the left side of river
%						 MR is the number of missionaries on the right side of river
%						 CL is the number of cannibals on the left side of river
%						 CR is the number of cannibals on the right side of river

% action(S1,S2) - Denote the state change that happens when an action is performed
%				  S1 is the current state, S2 is next state after the action

% below 2 actions show state change when boat alone move from left to right and right to left 
action([[ML,CL],[MR,CR],left], [[ML,CL],[MR,CR],right]).
action([[ML,CL],[MR,CR],right], [[ML,CL],[MR,CR],left]).

% below 2 show state change when 2 missionaries move left to right and right to left 
action([[ML,CL],[MR,CR],left], [[NewML,CL],[NewMR,CR],right]):-
	ML>=2,
	NewML is ML-2,
	NewMR is MR+2.
action([[ML,CL],[MR,CR],right], [[NewML,CL],[NewMR,CR],left]):-
	MR>=2,
	NewML is ML+2,
	NewMR is MR-2.

% below 2 show state change when 2 cannibals move left to right and right to left 
action([[ML,CL],[MR,CR],left], [[ML,NewCL],[MR,NewCR],right]):-
	CL>=2,
	NewCL is CL-2,
	NewCR is CR+2.
action([[ML,CL],[MR,CR],right], [[ML,NewCL],[MR,NewCR],left]):-
	CR>=2,
	NewCL is CL+2,
	NewCR is CR-2.

% below 2 show state change when 1 cannibals and 1 missionary move left to right and right to left 
action([[ML,CL],[MR,CR],left], [[NewML,NewCL],[NewMR,NewCR],right]):-
	ML>=1,
	CL>=1,
	NewML is ML-1,
	NewMR is MR+1,
	NewCL is CL-1,
	NewCR is CR+1.
action([[ML,CL],[MR,CR],right], [[NewML,NewCL],[NewMR,NewCR],left]):-
	MR>=1,
	CR>=1,
	NewML is ML+1,
	NewMR is MR-1,
	NewCL is CL+1,
	NewCR is CR-1.

% below 2 show state change when 1 missionary move left to right and right to left 
action([[ML,CL],[MR,CR],left], [[NewML,CL],[NewMR,CR],right]):-
	ML>=1,
	NewML is ML-1,
	NewMR is MR+1.
action([[ML,CL],[MR,CR],right], [[NewML,CL],[NewMR,CR],left]):-
	MR>=1,
	NewML is ML+1,
	NewMR is MR-1.

% below 2 show state change when 1 missionary move left to right and right to left 
action([[ML,CL],[MR,CR],left], [[ML,NewCL],[MR,NewCR],right]):-
	CL>=2,
	NewCL is CL-1,
	NewCR is CR+1.
action([[ML,CL],[MR,CR],right], [[ML,NewCL],[MR,NewCR],left]):-
	CR>=2,
	NewCL is CL+1,
	NewCR is CR-1.

% safeState(S) - is a rule used to check if the state is safe i.e if the number of cannibals does not exceed the number of missionaries
%				 safeState(S) is true if the state S is safe
safeState([[ML,CL],[MR,CR],_]):-
	(ML>0
->	ML>=CL
;	true),
    (MR>0
-> MR>=CR
;	true).

% children(S, Expanded) - is a rule used to generate all children of a state S by appliying all possible actions to it.
%						  S is a state, Expanded is a list that contains the states generated by applying possible actions to state S.
children([[ML,CL],[MR,CR],BS], Expanded):-
	findall(NS, action([[ML,CL],[MR,CR],BS],NS), Expanded).

% expand (X,Y,Z) - used to add the next state in a list of paths
% 				   X is a list of states that denotes a path, Y is the list of next state to be added in path
%				   Z is the new list of list of states (i.e a list of paths) that has the new node added to it
expand(X, [ ], [ ]). 
expand(X,[Y|Z],[[Y|X]|W ]) :-
	expand(X, Z, W ).

% bfs(Initial_State, Path, Goal) - Rule to do a bfs search from initial state to Goal. 
%								   Path would be a list of states generated using actions to move from intial state to goal state
bfs(Initial_State, Path, Goal):-
	bfs_path([[Initial_State]], TempPath, Goal),
	reverse(TempPath,Path).

% bfs_path(Paths, Goal) - Paths is a list of list of states (i.e) a list of paths, Goal is the goal state
% Base case bfs_path([[Goal|Path]|_],[Goal|Path],Goal) - Stop recursion when the current path has goal node and set path as the current path with the goal node
bfs_path([[Goal|Path]|_],[Goal|Path],Goal).

% Recursive case bfs_path([[CN|CPath]|Paths], Path, Goal) - [CN|CPath] is the current path in the list of path, Goal is goal state, Path is the path from initial to goal state
% a recurive call to bfs_paths is made with NewPaths if,
% 1) the last added node in the current path is safe
% 2) the last added node in the current path is not already in the path (loop checking)
% if the above conditions are satisified the list of possible adjucent node is found using childeren and a new list of paths is create using expand
% the new expanded paths is added to the end of the current list of Paths so that the list of paths acts as a queue and then a recursive call is made using new list of paths.								
bfs_path([[CN|CPath]|Paths],Path, Goal):-
	safeState(CN),
	not(member(CN, CPath)),
	children(CN, Adjacent),
	expand([CN|CPath], Adjacent, Expanded),
	append(Paths, Expanded, NewPaths),
	bfs_path(NewPaths, Path, Goal).

% recurcive Case bfs_path([[CN|CPath]|Paths], Goal) if the last added node in the list of paths is not safe then do a recursive call with the next path in the list of paths
bfs_path([[CN|CPath]|Paths], Path, Goal):-	
	not(safeState(CN)),
	bfs_path(Paths, Path, Goal).

% recurcive Case bfs_path([[CN|CPath]|Paths], Goal) if the last added node in the list of paths is already in the current path (loop) then do a recursive call with the next path in the list of paths
bfs_path([[CN|CPath]|Paths], Path, Goal):-
	member(CN, CPath),
	bfs_path(Paths, Path, Goal).

% dfs(Initial_State, Path, Goal) - Rule to do a dfs search from initial state to Goal. 
%								   Path would be a list of states generated using actions to move from intial state to goal state
dfs(Initial_State, Path, Goal):-
	dfs_path(Initial_State, [Initial_State], Path, Goal).

% dfs_path(CN, Visited, Path, Goal) - dfs_path rule used to find path using dfs search
%			CN is the current state in the search
%			Visited is a list of all visited nodes from initial state to current node is needed for loop checking
% 			Path is a list of list of state from initial node to current node, Goal is the goal state
%			Goal is the goal state

% Base case dfs_path(Goal, _, Goal, Goal) - Stop recursion when the current node has goal node, then the last node in paths is also the goal node
dfs_path(Goal, _, Goal, Goal).

% recursive case dfs_path(CN, Visited, [CN|Path], Goal) - Do a recurive search to get the path
% if the Paths is the path from initial state to NewCN where NewCN is a state generated by using action on CN(current node) and NewCN is safe and not already in the visisted list then 
% then the [CN|Path] is the path to current node (CN). 
dfs_path(CN, Visited, [CN|Path], Goal):-
	action(CN, NewCN),
	not(member(NewCN, Visited)),
	safeState(NewCN),
	dfs_path(NewCN,[NewCN|Visited],Path, Goal).
