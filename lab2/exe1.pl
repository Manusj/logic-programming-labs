% issorted(L) - true if a list is sorted in ascending order.
% base case of issorted(L) - list sorted when it is empty.
issorted([]).

% 2nd base case of issorted(L) - list sorted when it has just one element.
issorted([_]).

% 3rd base case of issorted(L) - list is sorted in ascending when it has 2 elements X, Y and X <= Y
issorted([X,Y]):-
	X=<Y.

% recursive case of issorted(L) - list sorted if we compare first 2 elements and then check the same for all sub lists
% generated by removing first element in parent list
issorted([X,Y|Xs]):-
	X=<Y,
	issorted([Y|Xs]).




% smallest(L, S) - S is the smallest number in the list L
% base case smallest([X], x) - if X the only number in the list then it is the smallest.
smallest([X], X).

% reursive case smallest([X,Y|Xs], Z) - remove larger elements in the list recursively to a single smallest element at the end of the recursion to unify with base case
% recursive case 1 smallest([X,Y|Xs], Z) - if Z smallest in list [X|Xs] and X<Y, then Z smallest in list [X,Y|Xs]
smallest([X,Y|Xs], Z):-
	X<Y,
	smallest([X|Xs], Z).

% recursive case 2 smallest([X,Y|Xs], Z) - if Z smallest in list [Y|Xs] and X>=Y, then Z smallest in list [X,Y|Xs]
smallest([X,Y|Xs], Z):-
	X>=Y,
	smallest([Y|Xs], Z).

% remove_elem(L,E,R) - rule used to remove a element E from list L to obtain new list R
% base case remove_elem([X|Xs],X,Xs) - If X is removed from [X|Xs] we get Xs
remove_elem([X|Xs],X,Xs).

%recursive case remove_elem([X|Xs],Y,[X|Z]) - if removing Y from Xs given Z the removing Y from [X|Xs] gives [X|Z]
remove_elem([X|Xs],Y,[X|Z]):-
	remove_elem(Xs,Y,Z).

% ssort(L, L1) - L1 is the list L sorted in ascending order by using selection sort
% base case ssort([],[]) - The sorted list of a empty list is an empty list
ssort([],[]).

% recursive case ssort(X,[S|Y]) - sorted list of X is [S|Y], if S is smallest element in X and Y is the list obtained by sorted the list Z which isobtained after removing S from X
ssort(X,[S|Y]):-
	smallest(X,S),
	remove_elem(X,S,Z),
	ssort(Z,Y).

% split(Pivot, L, LessList, MoreList) - Split list L into a lessList which contains elements less than piviot and a moreList which contains elements >= pivot
% base case split(Pivot, [], [], []) - moreList and lessList of an empty list is empty
split(_, [], [], []).

% recursive case 1 split(Pivot, [Head|Ls], [Head|LessList], MoreList) - If Head < Pviot then add Head to lessList, split the list again after removing Head 
split(Pivot, [Head|Ls], [Head|LessList], MoreList):-
	Head<Pivot,
	split(Pivot, Ls, LessList, MoreList).

% recursive case 2 split(Pivot, [Head|Ls], LessList, [Head|MoreList]) - If Head >= Pviot then add Head to moreList, split the list again after removing Head 
split(Pivot, [Head|Ls], LessList, [Head|MoreList]):-
	Head>=Pivot,
	split(Pivot, Ls, LessList, MoreList).

% qsort(L, L1) - L1 is the list L sorted in ascending order by using quick sort
% base case qsort([],[]) - The sorted list of a empty list is an empty list
qsort([],[]).

% recursive case qsort([L|Ls],LS) - split the list with head of list as pivot, sort the new lists obatined a the merge the lists 
qsort([L|Ls],LS):-
	split(L, Ls, LessList, MoreList),
	qsort(LessList, NewLessList),
	qsort(MoreList, NewMoreList),
	append(NewLessList, [L|NewMoreList], LS).


